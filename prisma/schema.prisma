// Prisma Schema for Paid - Bill Splitting Application
// This schema defines the database structure for a bill-splitting app
// with face detection-assisted player identification

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}
        
// =========================
// Enums
// =========================

enum SessionStatus {
  DRAFT
  PROCESSING_FACES
  READY_TO_SPLIT
  SPLIT_CONFIRMED
  CLOSED

  @@map("session_status")
}

enum ObligationStatus {
  PENDING
  MARKED_PAID
  VERIFIED
  REJECTED

  @@map("obligation_status")
}

enum MediaKind {
  GROUP_PHOTO
  PAYMENT_PROOF
  PROFILE_PHOTO

  @@map("media_kind")
}

enum ParticipantRole {
  HOST
  PLAYER

  @@map("participant_role")
}

enum PaymentMethod {
  CASH
  TRANSFER
  EWALLET
  OTHER

  @@map("payment_method")
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED

  @@map("verification_status")
}

// =========================
// Core Entities
// =========================

/// Registered app users who can host sessions
model User {
  id            String    @id @default(uuid()) @db.Uuid
  email         String    @unique @db.VarChar(255)
  passwordHash  String?   @map("password_hash") @db.VarChar(255)
  name          String    @db.VarChar(255)
  phone         String?   @db.VarChar(50)
  photoUrl      String?   @map("photo_url")
  isActive      Boolean   @default(true) @map("is_active")
  deletedAt     DateTime? @map("deleted_at") @db.Timestamptz
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  sessions           Session[]          @relation("HostedSessions")
  uploadedMedia      MediaAsset[]       @relation("UploadedMedia")
  faceConfirmations  FaceConfirmation[] @relation("ConfirmedBy")
  verifiedProofs     PaymentProof[]     @relation("VerifiedBy")
  linkedPlayer       Player?            @relation("LinkedUser")

  @@index([email], name: "idx_users_email")
  @@index([isActive], name: "idx_users_is_active")
  @@map("users")
}

/// Individuals who participate in bill splits
model Player {
  id        String    @id @default(uuid()) @db.Uuid
  userId    String?   @unique @map("user_id") @db.Uuid
  email     String?   @unique @db.VarChar(255)
  name      String    @db.VarChar(255)
  phone     String?   @db.VarChar(50)
  photoUrl  String?   @map("photo_url")
  isActive  Boolean   @default(true) @map("is_active")
  deletedAt DateTime? @map("deleted_at") @db.Timestamptz
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  linkedUser           User?                  @relation("LinkedUser", fields: [userId], references: [id], onDelete: SetNull)
  faceEmbeddings       PlayerFaceEmbedding[]
  sessionParticipants  SessionParticipant[]
  faceMatchSuggestions FaceMatchSuggestion[]
  faceConfirmations    FaceConfirmation[]
  obligationsAsPayer   Obligation[]           @relation("ObligationPayer")
  obligationsAsPayee   Obligation[]           @relation("ObligationPayee")
  magicLinkTokens      MagicLinkToken[]

  @@index([userId], name: "idx_players_user_id")
  @@index([email], name: "idx_players_email")
  @@map("players")
}

/// Stores enrolled face embeddings for known players
model PlayerFaceEmbedding {
  id              String    @id @default(uuid()) @db.Uuid
  playerId        String    @map("player_id") @db.Uuid
  embedding       Bytes     // Using Bytes as fallback; pgvector would use vector(512)
  sourcePhotoUrl  String?   @map("source_photo_url")
  isActive        Boolean   @default(true) @map("is_active")
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@index([playerId], name: "idx_player_face_embeddings_player_id")
  @@map("player_face_embeddings")
}

/// A bill-splitting session/event
model Session {
  id            String        @id @default(uuid()) @db.Uuid
  hostId        String        @map("host_id") @db.Uuid
  name          String        @db.VarChar(255)
  description   String?
  status        SessionStatus @default(DRAFT)
  groupPhotoUrl String?       @map("group_photo_url")
  totalAmount   Decimal?      @map("total_amount") @db.Decimal(12, 2)
  sessionDate   DateTime?     @map("session_date") @db.Timestamptz
  isActive      Boolean       @default(true) @map("is_active")
  deletedAt     DateTime?     @map("deleted_at") @db.Timestamptz
  createdAt     DateTime      @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime      @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  host          User                 @relation("HostedSessions", fields: [hostId], references: [id], onDelete: Cascade)
  participants  SessionParticipant[]
  expenseItems  ExpenseItem[]
  mediaAssets   MediaAsset[]
  detectedFaces DetectedFace[]
  obligations   Obligation[]

  @@index([hostId], name: "idx_sessions_host_id")
  @@index([status], name: "idx_sessions_status")
  @@index([sessionDate], name: "idx_sessions_session_date")
  @@map("sessions")
}

/// Junction table linking players to sessions
model SessionParticipant {
  id        String          @id @default(uuid()) @db.Uuid
  sessionId String          @map("session_id") @db.Uuid
  playerId  String          @map("player_id") @db.Uuid
  role      ParticipantRole @default(PLAYER)
  joinedAt  DateTime        @default(now()) @map("joined_at") @db.Timestamptz
  isActive  Boolean         @default(true) @map("is_active")
  createdAt DateTime        @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime        @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  player  Player  @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([sessionId, playerId])
  @@index([sessionId], name: "idx_session_participants_session_id")
  @@index([playerId], name: "idx_session_participants_player_id")
  @@map("session_participants")
}

/// Individual expense line items within a session
model ExpenseItem {
  id          String   @id @default(uuid()) @db.Uuid
  sessionId   String   @map("session_id") @db.Uuid
  description String   @db.VarChar(255)
  amount      Decimal  @db.Decimal(12, 2)
  quantity    Int      @default(1)
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId], name: "idx_expense_items_session_id")
  @@map("expense_items")
}

/// Centralized storage for all uploaded files
model MediaAsset {
  id            String    @id @default(uuid()) @db.Uuid
  sessionId     String?   @map("session_id") @db.Uuid
  uploadedBy    String    @map("uploaded_by") @db.Uuid
  kind          MediaKind
  storageUrl    String    @map("storage_url")
  mimeType      String    @map("mime_type") @db.VarChar(100)
  fileSizeBytes Int?      @map("file_size_bytes")
  metadata      Json?
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  session       Session?       @relation(fields: [sessionId], references: [id], onDelete: SetNull)
  uploader      User           @relation("UploadedMedia", fields: [uploadedBy], references: [id], onDelete: Cascade)
  detectedFaces DetectedFace[]
  paymentProofs PaymentProof[]

  @@index([sessionId], name: "idx_media_assets_session_id")
  @@index([kind], name: "idx_media_assets_kind")
  @@map("media_assets")
}

/// Faces detected in session group photos
model DetectedFace {
  id           String   @id @default(uuid()) @db.Uuid
  sessionId    String   @map("session_id") @db.Uuid
  mediaAssetId String   @map("media_asset_id") @db.Uuid
  boundingBox  Json     @map("bounding_box") // {x, y, width, height}
  embedding    Bytes    // Using Bytes as fallback; pgvector would use vector(512)
  faceIndex    Int      @map("face_index")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  session            Session               @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  mediaAsset         MediaAsset            @relation(fields: [mediaAssetId], references: [id], onDelete: Cascade)
  matchSuggestions   FaceMatchSuggestion[]
  faceConfirmation   FaceConfirmation?

  @@unique([mediaAssetId, faceIndex])
  @@index([sessionId], name: "idx_detected_faces_session_id")
  @@map("detected_faces")
}

/// AI-generated suggestions matching detected faces to known players
model FaceMatchSuggestion {
  id                String   @id @default(uuid()) @db.Uuid
  detectedFaceId    String   @map("detected_face_id") @db.Uuid
  suggestedPlayerId String   @map("suggested_player_id") @db.Uuid
  confidenceScore   Decimal  @map("confidence_score") @db.Decimal(5, 4)
  rank              Int
  createdAt         DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  detectedFace    DetectedFace @relation(fields: [detectedFaceId], references: [id], onDelete: Cascade)
  suggestedPlayer Player       @relation(fields: [suggestedPlayerId], references: [id], onDelete: Cascade)

  @@unique([detectedFaceId, suggestedPlayerId])
  @@index([detectedFaceId], name: "idx_face_match_suggestions_detected_face_id")
  @@map("face_match_suggestions")
}

/// Host-confirmed mappings from detected faces to players
model FaceConfirmation {
  id             String   @id @default(uuid()) @db.Uuid
  detectedFaceId String   @unique @map("detected_face_id") @db.Uuid
  playerId       String   @map("player_id") @db.Uuid
  confirmedBy    String   @map("confirmed_by") @db.Uuid
  confirmedAt    DateTime @default(now()) @map("confirmed_at") @db.Timestamptz

  // Relations
  detectedFace DetectedFace @relation(fields: [detectedFaceId], references: [id], onDelete: Cascade)
  player       Player       @relation(fields: [playerId], references: [id], onDelete: Cascade)
  confirmer    User         @relation("ConfirmedBy", fields: [confirmedBy], references: [id], onDelete: Cascade)

  @@index([playerId], name: "idx_face_confirmations_player_id")
  @@map("face_confirmations")
}

/// Payment obligations generated after split confirmation
model Obligation {
  id             String           @id @default(uuid()) @db.Uuid
  sessionId      String           @map("session_id") @db.Uuid
  payerId        String           @map("payer_id") @db.Uuid
  payeeId        String           @map("payee_id") @db.Uuid
  amount         Decimal          @db.Decimal(12, 2)
  status         ObligationStatus @default(PENDING)
  idempotencyKey String           @unique @map("idempotency_key") @db.VarChar(255)
  createdAt      DateTime         @default(now()) @map("created_at") @db.Timestamptz
  updatedAt      DateTime         @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  session  Session   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  payer    Player    @relation("ObligationPayer", fields: [payerId], references: [id], onDelete: Cascade)
  payee    Player    @relation("ObligationPayee", fields: [payeeId], references: [id], onDelete: Cascade)
  payments Payment[]

  @@unique([sessionId, payerId])
  @@index([sessionId], name: "idx_obligations_session_id")
  @@index([payerId], name: "idx_obligations_payer_id")
  @@index([status], name: "idx_obligations_status")
  @@map("obligations")
}

/// Payment records when a player marks an obligation as paid
model Payment {
  id              String        @id @default(uuid()) @db.Uuid
  obligationId    String        @map("obligation_id") @db.Uuid
  method          PaymentMethod
  amount          Decimal       @db.Decimal(12, 2)
  referenceNumber String?       @map("reference_number") @db.VarChar(255)
  paidAt          DateTime      @default(now()) @map("paid_at") @db.Timestamptz
  createdAt       DateTime      @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime      @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  obligation Obligation     @relation(fields: [obligationId], references: [id], onDelete: Cascade)
  proofs     PaymentProof[]

  @@index([obligationId], name: "idx_payments_obligation_id")
  @@map("payments")
}

/// Uploaded proof of payment and verification status
model PaymentProof {
  id              String             @id @default(uuid()) @db.Uuid
  paymentId       String             @map("payment_id") @db.Uuid
  mediaAssetId    String             @map("media_asset_id") @db.Uuid
  status          VerificationStatus @default(PENDING)
  verifiedBy      String?            @map("verified_by") @db.Uuid
  rejectionReason String?            @map("rejection_reason")
  verifiedAt      DateTime?          @map("verified_at") @db.Timestamptz
  createdAt       DateTime           @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime           @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  payment    Payment    @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  mediaAsset MediaAsset @relation(fields: [mediaAssetId], references: [id], onDelete: Cascade)
  verifier   User?      @relation("VerifiedBy", fields: [verifiedBy], references: [id], onDelete: SetNull)

  @@index([paymentId], name: "idx_payment_proofs_payment_id")
  @@index([status], name: "idx_payment_proofs_status")
  @@map("payment_proofs")
}

/// Short-lived tokens for outside-app access
model MagicLinkToken {
  id        String    @id @default(uuid()) @db.Uuid
  playerId  String    @map("player_id") @db.Uuid
  tokenHash String    @unique @map("token_hash") @db.VarChar(255)
  expiresAt DateTime  @map("expires_at") @db.Timestamptz
  usedAt    DateTime? @map("used_at") @db.Timestamptz
  purpose   String    @db.VarChar(50)
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@index([tokenHash], name: "idx_magic_link_tokens_token_hash")
  @@index([playerId], name: "idx_magic_link_tokens_player_id")
  @@index([expiresAt], name: "idx_magic_link_tokens_expires_at")
  @@map("magic_link_tokens")
}
